# Set the include path for all projects within this directory tree to always be relative
# to src. Don't define other include paths. This keeps includes exceedingly clean and
# regular, and it makes includes unambiguous instead of mysterious.
# Also, force all builds to be done with C++ 11 syntax and libraries.
env = Environment(CPPPATH='#/src', CXXFLAGS='-std=c++0x')

AddOption('--verbose', dest='verbose', action='store_true', help='Display more details during build.')
AddOption('--release', dest='release', action='store_true', help='Do a release build instead of debug.')

# Unless the user requests verbose mode, simplify the strings that get displayed
# as each file is handled.
if not GetOption('verbose'):
    env['CXXCOMSTR'] = "Compiling $SOURCE ..."
    env['LINKCOMSTR'] = "Linking $TARGET ..."

if GetOption('release'):
	env['CCFLAGS'] = '-O3 -D_FILE_OFFSET_BITS=64'
else:
	env['CCFLAGS'] = '-g -D_FILE_OFFSET_BITS=64'

# Make sure all other scripts can use the Environments we've built.
Export('env')

# Build the base library for nitro, both release and debug.
base = SConscript('src/base/sconscript', variant_dir='build/base', duplicate=0)
Export('base')

# Build the domain library for nitro, both release and debug.
domain = SConscript('src/domain/sconscript', variant_dir='build/domain', duplicate=0)
Export('domain')

# Build the main binary, both release and debug.
binary = SConscript('src/nitro/sconscript', variant_dir='build/nitro', duplicate=0)
Default(binary)

# Build tests, both release and debug.
testrunner = SConscript('src/test/sconscript', variant_dir='build/test', duplicate=0)

Default(testrunner)

# -------------------- gory and mostly uninteresting details --------------------

# Do some very simple sanity checking on tools. Prove that we have a compiler
# that's able to deal with C++ 11 constructs (typically, g++ 4.6 or later).
config = Configure(env)
if not config.CheckCXX():
	print('C++ compiler unavailable.')
	Exit(1)

# Check to see if we can see some headers that we're likely to need. This
# check can be representative rather than exhaustive, because the bar for
# portability is modest (we're only going to be building this at Adaptive,
# on relatively similar systems). I've picked a couple that virtually guarantee
# the presence of more common ones.
required_headers = ['unordered_map', 'cstdint']
missing = []
for rh in required_headers:
	if not config.CheckHeader(rh, language='C++'):
		missing.append(rh)
if missing:
	print('The following headers are unavailable, but required to compile: %s' % ', '.join(['<%s>' % h for h in missing]))
	Exit(1)


